#!/usr/bin/env bash

set -o errexit
# Check if $IMAGE is not set or is empty

if [ -z "$IMAGE" ]; then
  echo "ERROR: IMAGE environment variable is not set."
  exit 1
fi

echo "Deploying image $IMAGE to Kubernetes..."

export KUBECONFIG="{{ kubeconfig }}"

echo "Running pre-deployment tasks..."

# Create new release job

release_job_id=$(head -c 12 /dev/urandom | base64 | tr -dc 'a-z0-9' | head -c 12)
release_job_name="django-release-job-$release_job_id"

release_job_yaml=$(cat <<EOF
apiVersion: batch/v1
kind: Job
metadata:
  name: $release_job_name
spec:
  template:
    spec:
      containers:
        - name: django
          image: $IMAGE
          command: ["/bin/sh", "-c"]
          args: ["./release.sh"]
          envFrom:
            - configMapRef:
                name: configmap
            - secretRef:
                name: secrets
      restartPolicy: Never
      nodeSelector:
        role: jobrunner

EOF
)

echo "$release_job_yaml" | kubectl apply -f - -n default

# Wait for the release job to complete: 60 seconds timeout
kubectl wait --for=condition=complete job/"$release_job_name" --timeout=60s || true

release_pod_name=$(kubectl get pods -l job-name="$release_job_name" -o jsonpath='{.items[0].metadata.name}')
release_pod_status=$(kubectl get pod "$release_pod_name" -o jsonpath='{.status.phase}')

# Display logs of the release job if available
if kubectl get pod "$release_pod_name" &>/dev/null; then
  kubectl logs "$release_pod_name"
fi

# Delete the job
kubectl delete job "$release_job_name"

if [ "$release_pod_status" != 'Succeeded' ]; then
  echo "ERROR: Release job failed with status $release_pod_status"
  exit 1
fi

echo "Deploying application..."

kubectl set image deployment/django-app django="${IMAGE}" -n default
kubectl rollout status deployment/django-app -n default

echo "Updating cron jobs..."

{% for cronjob in cronjobs %}
kubectl set image cronjob/{{ cronjob.name }} django="${IMAGE}" -n default
{% endfor %}
