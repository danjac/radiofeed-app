- name: Deploy Kubernetes
  environment:
      KUBECONFIG: "{{ kubeconfig }}"
  vars:
      memory_request_percent: 0.4
      memory_limit_percent: 0.75
      cpu_request_percent: 0.35
      cpu_limit_percent: 0.8
      cloudflare_cert: "cloudflare.pem"
      cloudflare_key: "cloudflare.key"
      cloudflare_certs:
          - "{{ cloudflare_cert }}"
          - "{{ cloudflare_key }}"
  block:
      - name: Copy Cloudflare certs to target node
        ansible.builtin.copy:
            src: "{{ playbook_dir }}/certs/{{ item }}"
            dest: "/tmp/{{ item | basename }}"
            mode: "0600"
        loop: "{{ cloudflare_certs }}"

      - name: Create Kubernetes TLS Secret
        ansible.builtin.shell:
            cmd: |
              set -o pipefail && kubectl create secret tls cloudflare-origin-cert \
                  --cert=/tmp/{{ cloudflare_cert }} \
                  --key=/tmp/{{ cloudflare_key }} \
                  -n default --dry-run=client -o yaml | kubectl apply -f -
            executable: /bin/bash
        changed_when: true

      - name: Remove certs from /tmp after secret is created
        ansible.builtin.file:
            path: "/tmp/{{ item }}"
            state: absent
        loop: "{{ cloudflare_certs }}"

      - name: Label the nodes
        ansible.builtin.shell: |
            kubectl label nodes {{ hostvars[item].hostname }} role={{ hostvars[item].role }} --overwrite
        loop: "{{ groups['all'] }}"
        changed_when: true

      - name: Force CoreDNS to run on the server node
        ansible.builtin.shell: |
            kubectl patch deployment coredns -n kube-system \
              --type='json' \
              -p='[{"op": "add", "path": "/spec/template/spec/nodeSelector", "value": {"role": "server"}}]'
        changed_when: true

      - name: Restart CoreDNS to apply changes
        ansible.builtin.shell: |
            kubectl rollout restart deployment/coredns -n kube-system
        changed_when: true

      - name: Force metrics-server to run on the server node
        ansible.builtin.shell: |
            kubectl patch deployment metrics-server -n kube-system \
              --type='json' \
              -p='[{"op": "add", "path": "/spec/template/spec/nodeSelector", "value": {"role": "server"}}]'
        changed_when: true

      - name: Restart metrics-server to apply changes
        ansible.builtin.shell: |
            kubectl rollout restart deployment/metrics-server -n kube-system
        changed_when: true

      - name: Force Traefik to run on the server node
        ansible.builtin.shell: |
            kubectl patch deployment traefik -n kube-system \
              --type='json' \
              -p='[{"op": "add", "path": "/spec/template/spec/nodeSelector", "value": {"role": "server"}}]'
        changed_when: true

      - name: Restart Traefik to apply changes
        ansible.builtin.shell: |
            kubectl rollout restart deployment/traefik -n kube-system
        changed_when: true

      - name: Get the current image of running django-app pod
        ansible.builtin.shell: |
            kubectl get pods -l app=django-app -o jsonpath='{.items[0].spec.containers[0].image}' -n default
        register: k3s_deploy_current_image
        changed_when: false
        ignore_errors: true

      - name: Set default image if current image is empty
        ansible.builtin.set_fact:
            k3s_deploy_image: "{{ k3s_deploy_current_image.stdout if k3s_deploy_current_image.stdout | length > 0 else k3s_deploy_docker_image }}"
        changed_when: false
        when: k3s_deploy_current_image is defined and k3s_deploy_current_image.stdout is defined

      - name: Create a temporary directory
        ansible.builtin.tempfile:
            state: directory
        register: k3s_deploy_manifests_dir

      - name: Calculate total resources
        ansible.builtin.set_fact:
            k3s_deploy_total_memory_mb: "{{ ansible_memtotal_mb }}"
            k3s_deploy_total_cpu_millicores: "{{ ansible_processor_vcpus * 1000 }}"

      - name: Calculate resource requests/limits
        ansible.builtin.set_fact:
            k3s_deploy_mem_request: "{{ (k3s_deploy_total_memory_mb | int * memory_request_percent) | int }}Mi"
            k3s_deploy_mem_limit: "{{ (k3s_deploy_total_memory_mb | int * memory_limit_percent) | int }}Mi"
            k3s_deploy_cpu_request: "{{ (k3s_deploy_total_cpu_millicores | int * cpu_request_percent) | int }}m"
            k3s_deploy_cpu_limit: "{{ (k3s_deploy_total_cpu_millicores | int * cpu_limit_percent) | int }}m"

      - name: Render Kubernetes manifests
        vars:
            database_url: "postgresql://postgres:{{ k3s_deploy_postgres_password }}@postgres.default.svc.cluster.local:5432/postgres"
            redis_url: "redis://redis.default.svc.cluster.local:6379/0"
            manage_cmd: "python ./manage.py"
            num_webapps: "{{ groups['agents'] | map('extract', hostvars, 'role') | select('equalto', 'webapp') | length }}"
            postgres_major_version: "{{ k3s_deploy_postgres_image.split(':')[1].split('.')[0] }}"
        ansible.builtin.template:
            src: "{{ item }}.yaml.j2"
            dest: "{{ k3s_deploy_manifests_dir.path + '/' + item + '.yaml' }}"
            mode: "0644"
        loop:
            - configmap
            - secrets
            - postgres_pv
            - postgres_pvc
            - postgres_statefulset
            - postgres_service
            - redis_deployment
            - redis_service
            - django_deployment
            - django_service
            - django_worker_deployment
            - ingress_route

      - name: Apply Kubernetes manifests using ApplySet
        ansible.builtin.shell: |
            kubectl apply -f {{ k3s_deploy_manifests_dir.path }} --prune --applyset=app-deployment --namespace=default
        environment:
            KUBECTL_APPLYSET: "true"
        changed_when: true

      - name: Delete manifests dir
        ansible.builtin.file:
            path: "{{ k3s_deploy_manifests_dir.path }}"
            state: absent

      - name: Restart statefulsets
        ansible.builtin.shell: |
            for statefulset in $(kubectl get statefulsets -n default -o jsonpath='{.items[*].metadata.name}'); do
              kubectl rollout restart statefulset/$statefulset -n default
            done
        changed_when: true

      - name: Restart deployments
        ansible.builtin.shell: |
            for deployment in $(kubectl get deployments -n default -o jsonpath='{.items[*].metadata.name}'); do
              kubectl rollout restart deployment/$deployment -n default
            done
        changed_when: true
